import chalk from 'chalk';
import ora from 'ora';
import fs from 'fs-extra';
import path from 'path';
import { Project, SyntaxKind } from 'ts-morph';

export async function generate(options: { output: string }) {
  const spinner = ora('Scanning for actions...').start();
  const cwd = process.cwd();

  // Use ts-morph to scan all ts/tsx files
  const project = new Project({
    tsConfigFilePath: path.join(cwd, 'tsconfig.json'),
    skipAddingFilesFromTsConfig: false,
  });

  const actions: {
    id: string;
    description: string;
    hasInput: boolean;
    inputSchema?: Record<string, unknown>;
  }[] = [];

  // Find all act.action() calls
  for (const sourceFile of project.getSourceFiles()) {
    // Skip node_modules and dist
    if (
      sourceFile.getFilePath().includes('node_modules') ||
      sourceFile.getFilePath().includes('dist')
    )
      continue;

    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const expr = call.getExpression();

      // Match act.action({...})
      if (!expr.getText().endsWith('.action')) continue;

      const args = call.getArguments();
      if (!args[0]) continue;

      // Parse the meta object
      const metaObj = args[0];
      if (metaObj.getKind() !== SyntaxKind.ObjectLiteralExpression) continue;

      const properties = metaObj.getDescendantsOfKind(SyntaxKind.PropertyAssignment);

      const meta: Record<string, string> = {};
      for (const prop of properties) {
        const name = prop.getName();
        const value = prop.getInitializer()?.getText().replace(/['"]/g, '') ?? '';
        meta[name] = value;
      }

      if (!meta['id'] || !meta['description']) continue;

      const hasInput = !!meta['input'];

      actions.push({
        id: meta['id'],
        description: meta['description'],
        hasInput,
      });
    }
  }

  spinner.succeed(`Found ${chalk.cyan(actions.length)} actions`);

  if (actions.length === 0) {
    console.log(
      chalk.yellow(
        "\n  No actions found. Make sure you're using act.action({id, description})(fn)\n",
      ),
    );
    return;
  }

  // Read existing config to preserve apiKey, projectId etc
  const configPath = path.join(cwd, options.output);
  let existingConfig = {
    apiKey: 'process.env.NEXT_PUBLIC_ACT_API_KEY!',
    projectId: 'proj_',
    description: 'My application',
    restrictedRoutes: [] as string[],
  };

  if (await fs.pathExists(configPath)) {
    // Basic extraction of existing values — don't overwrite them
    const content = await fs.readFile(configPath, 'utf-8');
    const projectIdMatch = content.match(/projectId:\s*["'](.+?)["']/);
    const descMatch = content.match(/description:\s*["'](.+?)["']/);
    if (projectIdMatch?.[1]) existingConfig.projectId = projectIdMatch[1];
    if (descMatch?.[1]) existingConfig.description = descMatch[1];
  }

  // Write config
  const configContent = `import { defineConfig } from "@act-sdk/core"

// Auto-generated by: npx act-sdk generate
// Run again after adding new actions

export default defineConfig({
  apiKey: ${existingConfig.apiKey},
  projectId: "${existingConfig.projectId}",
  description: "${existingConfig.description}",
  restrictedRoutes: ${JSON.stringify(existingConfig.restrictedRoutes)},
})
`;

  await fs.outputFile(configPath, configContent);

  console.log(chalk.dim('\n  Generated actions:'));
  actions.forEach((a) => {
    console.log(`  ${chalk.green('✓')} ${chalk.cyan(a.id)} — ${a.description}`);
  });
  console.log(`\n  Config written to ${chalk.cyan(options.output)}\n`);
}
